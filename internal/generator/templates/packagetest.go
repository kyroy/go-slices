// Copyright 2018 Dennis Kuhnert
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package internal

import (
	"text/template"
)

// PackageTestTemplate is the template to generate {type}/{type}_test.go
var PackageTestTemplate = template.Must(template.New("package_test.go").Parse(`// Code generated by go generate; DO NOT EDIT.

// Copyright 2018 Dennis Kuhnert
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package {{ .Package }}_test
{{ if .Tests }}
import (
	"fmt"
	"github.com/kyroy/go-slices/{{ .Package }}"
	"github.com/stretchr/testify/assert"
	"testing"
)

var _ = fmt.Print
{{ if .Tests.Map }}
func TestMap(t *testing.T) {
	type args struct {
		s []{{ .Type }}
		f func(s {{ .Type }}) {{ .Type }}
	}
	tests := []struct {
		name string
		args args
		want []{{ .Type }}
	}{
		{{ range .Tests.Map }}{
			name: "{{ .Name }}",
			args: args{
				s: []{{ $.Type }}{{ .In }},
				f: func(x {{ $.Type }}) {{ $.Type }} {{ .Func }},
			},
			want: []{{ $.Type }}{{ .Out }},
		},{{end}}
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var got []{{ .Type }} = {{ .Package }}.Map(tt.args.s, tt.args.f)
			assert.Equal(t, tt.want, got)
			got = {{ .Package }}.New(tt.args.s).Map(tt.args.f)
			assert.Equal(t, tt.want, got)
		})
	}
}{{ end }}
{{ if .Tests.Filter }}
func TestFilter(t *testing.T) {
	type args struct {
		s []{{ .Type }}
		f func(s {{ .Type }}) bool
	}
	tests := []struct {
		name string
		args args
		want []{{ .Type }}
	}{
		{{ range .Tests.Filter }}{
			name: "{{ .Name }}",
			args: args{
				s: []{{ $.Type }}{{ .In }},
				f: func(x {{ $.Type }}) bool {{ .Func }},
			},
			want: []{{ $.Type }}{{ .Out }},
		},{{ end }}
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var got []{{ .Type }} = {{ .Package }}.Filter(tt.args.s, tt.args.f)
			assert.Equal(t, tt.want, got)
			got = {{ .Package }}.New(tt.args.s).Filter(tt.args.f)
			assert.Equal(t, tt.want, got)
		})
	}
}{{ end }}
{{ if .Tests.Reduce }}
func TestReduce(t *testing.T) {
	type args struct {
		s       []{{ .Type }}
		f       func(sum, value {{ .Type }}) {{ .Type }}
		neutral {{ .Type }}
	}
	tests := []struct {
		name string
		args args
		want {{ .Type }}
	}{
		{{ range .Tests.Reduce }}{
			name: "{{ .Name }}",
			args: args{
				s:       []{{ $.Type }}{{ .In }},
				f:       func(sum, value {{ $.Type }}) {{ $.Type }} {{ .Func }},
				neutral: {{ .Neutral }},
			},
			want: {{ .Out }},
		},{{ end }}
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var got {{ .Type }} = {{ .Package }}.Reduce(tt.args.s, tt.args.f, tt.args.neutral)
			assert.Equal(t, tt.want, got)
			got = {{ .Package }}.New(tt.args.s).Reduce(tt.args.f, tt.args.neutral)
			assert.Equal(t, tt.want, got)
		})
	}
}{{ end }}
{{ if .Tests.Unique }}
func TestUnique(t *testing.T) {
	type args struct {
		s []{{ .Type }}
	}
	tests := []struct {
		name string
		args args
		want []{{ .Type }}
	}{
		{{ range .Tests.Unique }}{
			name: "{{ .Name }}",
			args: args{
				s: []{{ $.Type }}{{ .In }},
			},
			want: []{{ $.Type }}{{ .Out }},
		},{{ end }}
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var got []{{ .Type }} = {{ .Package }}.Unique(tt.args.s)
			assert.Equal(t, tt.want, got)
			got = {{ .Package }}.New(tt.args.s).Unique()
			assert.Equal(t, tt.want, got)
		})
	}
}{{ end }}
{{ if .Tests.Intersect }}
func TestIntersect(t *testing.T) {
	type args struct {
		s    []{{ .Type }}
		more [][]{{ .Type }}
	}
	tests := []struct {
		name string
		args args
		want []{{ .Type }}
	}{
		{{ range .Tests.Intersect }}{
			name: "{{ .Name }}",
			args: args{
				s: []{{ $.Type }}{{ .In }},
				more: [][]{{ $.Type }}{{ .More }},
			},
			want: []{{ $.Type }}{{ .Out }},
		},{{ end }}
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var got []{{ .Type }} = {{ .Package }}.Intersect(tt.args.s, tt.args.more...)
			assert.ElementsMatch(t, tt.want, got)
			got = {{ .Package }}.New(tt.args.s).Intersect(tt.args.more...)
			assert.ElementsMatch(t, tt.want, got)
		})
	}
}{{ end }}
{{ if .Tests.Contains }}
func TestContains(t *testing.T) {
	type args struct {
		s []{{ .Type }}
		x {{ .Type }}
	}
	tests := []struct {
		name string
		args args
		want bool
	}{
		{{ range .Tests.Contains }}{
			name: "{{ .Name }}",
			args: args{
				s: []{{ $.Type }}{{ .In }},
				x: {{ .Elem }},
			},
			want: {{ .Out }},
		},{{ end }}
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var got bool = {{ .Package }}.Contains(tt.args.s, tt.args.x)
			assert.Equal(t, tt.want, got)
			got = {{ .Package }}.New(tt.args.s).Contains(tt.args.x)
			assert.Equal(t, tt.want, got)
		})
	}
}{{ end }}
{{ if .Tests.IndexOf }}
func TestIndexOf(t *testing.T) {
	type args struct {
		s []{{ .Type }}
		x {{ .Type }}
	}
	tests := []struct {
		name string
		args args
		want int
	}{
		{{ range .Tests.IndexOf }}{
			name: "{{ .Name }}",
			args: args{
				s: []{{ $.Type }}{{ .In }},
				x: {{ .Elem }},
			},
			want: {{ .Out }},
		},{{ end }}
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var got int = {{ .Package }}.IndexOf(tt.args.s, tt.args.x)
			assert.Equal(t, tt.want, got)
			got = {{ .Package }}.New(tt.args.s).IndexOf(tt.args.x)
			assert.Equal(t, tt.want, got)
		})
	}
}{{ end }}
{{ if .Tests.Find }}
func TestFind(t *testing.T) {
	type args struct {
		s []{{ .Type }}
		f func({{ .Type }}) bool
	}
	tests := []struct {
		name string
		args args
		want {{ .Type }}
		found bool
	}{
		{{ range .Tests.Find }}{
			name: "{{ .Name }}",
			args: args{
				s: []{{ $.Type }}{{ .In }},
				f: func(x {{ $.Type }}) bool {{ .Func }},
			},
			want: {{ .Out }},
			found: {{ .Found }},
		},{{ end }}
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var got1 *{{ .Type }} = {{ .Package }}.Find(tt.args.s, tt.args.f)
			var got2 *{{ .Type }} = {{ .Package }}.New(tt.args.s).Find(tt.args.f)
			if tt.found {
				assert.Equal(t, &tt.want, got1)
				assert.Equal(t, &tt.want, got2)
			} else {
				assert.Nil(t, got1)
				assert.Nil(t, got2)
			}
		})
	}
}{{ end }}
{{ end }}`))
