// Copyright 2018 Dennis Kuhnert
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package internal

import (
	"text/template"
)

// PackageTestTemplate is the template to generate {type}/{type}_test.go
var PackageTestTemplate = template.Must(template.New("package_test.go").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated at {{ .Timestamp.Format "2006 Jan 02 15:04:05 UTC" }}

// Copyright 2018 Dennis Kuhnert
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package {{ .Package }}_test

import (
	"github.com/kyroy/go-slices/{{ .Package }}"
	"github.com/stretchr/testify/assert"
	"testing"
	"fmt"
)

var _ = fmt.Print
{{ if .Map }}
func TestMap(t *testing.T) {
	type args struct {
		s []{{ .Type }}
		f func(s {{ .Type }}) {{ .Type }}
	}
	tests := []struct {
		name string
		args args
		want []{{ .Type }}
	}{
		{{ range .Map }}{
			name: "{{ .Name }}",
			args: args{
				s: []{{ $.Type }}{{ .In }},
				f: func(x {{ $.Type }}) {{ $.Type }} {{ .Func }},
			},
			want: []{{ $.Type }}{{ .Out }},
		},{{end}}
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var got []{{ .Type }} = {{ .Package }}.Map(tt.args.s, tt.args.f)
			assert.Equal(t, tt.want, got)
			got = {{ .Package }}.New(tt.args.s).Map(tt.args.f)
			assert.Equal(t, tt.want, got)
		})
	}
}{{ end }}
{{ if .Filter }}
func TestFilter(t *testing.T) {
	type args struct {
		s []{{ .Type }}
		f func(s {{ .Type }}) bool
	}
	tests := []struct {
		name string
		args args
		want []{{ .Type }}
	}{
		{{ range .Filter }}{
			name: "{{ .Name }}",
			args: args{
				s: []{{ $.Type }}{{ .In }},
				f: func(x {{ $.Type }}) bool {{ .Func }},
			},
			want: []{{ $.Type }}{{ .Out }},
		},{{ end }}
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var got []{{ .Type }} = {{ .Package }}.Filter(tt.args.s, tt.args.f)
			assert.Equal(t, tt.want, got)
			got = {{ .Package }}.New(tt.args.s).Filter(tt.args.f)
			assert.Equal(t, tt.want, got)
		})
	}
}{{ end }}
{{ if .Reduce }}
func TestReduce(t *testing.T) {
	type args struct {
		s       []{{ .Type }}
		f       func(sum, value {{ .Type }}) {{ .Type }}
		neutral {{ .Type }}
	}
	tests := []struct {
		name string
		args args
		want {{ .Type }}
	}{
		{{ range .Reduce }}{
			name: "{{ .Name }}",
			args: args{
				s:       []{{ $.Type }}{{ .In }},
				f:       func(sum, value {{ $.Type }}) {{ $.Type }} {{ .Func }},
				neutral: {{ .Neutral }},
			},
			want: {{ .Out }},
		},{{ end }}
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var got {{ .Type }} = {{ .Package }}.Reduce(tt.args.s, tt.args.f, tt.args.neutral)
			assert.Equal(t, tt.want, got)
			got = {{ .Package }}.New(tt.args.s).Reduce(tt.args.f, tt.args.neutral)
			assert.Equal(t, tt.want, got)
		})
	}
}{{ end }}
{{ if .Unique }}
func TestUnique(t *testing.T) {
	type args struct {
		s []{{ .Type }}
	}
	tests := []struct {
		name string
		args args
		want []{{ .Type }}
	}{
		{{ range .Unique }}{
			name: "{{ .Name }}",
			args: args{
				s: []{{ $.Type }}{{ .In }},
			},
			want: []{{ $.Type }}{{ .Out }},
		},{{ end }}
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var got []{{ .Type }} = {{ .Package }}.Unique(tt.args.s)
			assert.Equal(t, tt.want, got)
			got = {{ .Package }}.New(tt.args.s).Unique()
			assert.Equal(t, tt.want, got)
		})
	}
}{{ end }}
`))
